#include <iostream>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
using namespace std;

sem_t mutex, db;   // mutex for rc, db for writer lock
int rc = 0;        // reader count
int dataVar = 0;   // shared data

void* reader(void* arg) {
    while (true) {

        sem_wait(&mutex);        // lock rc
        rc++;
        if (rc == 1)             // first reader locks db
            sem_wait(&db);
        sem_post(&mutex);        // release rc lock

        cout << "Reader reads: " << dataVar << endl;
        sleep(1);

        sem_wait(&mutex);        // lock rc
        rc--;
        if (rc == 0)             // last reader unlocks db
            sem_post(&db);
        sem_post(&mutex);        // release rc lock

        sleep(1);
    }
    return NULL;
}

void* writer(void* arg) {
    while (true) {

        sem_wait(&db);           // writer needs exclusive access

        dataVar++;
        cout << "Writer writes: " << dataVar << endl;
        sleep(1);

        sem_post(&db);           // release database
        sleep(1);
    }
    return NULL;
}

int main() {
    pthread_t r1, r2, w1;

    sem_init(&mutex, 0, 1);
    sem_init(&db, 0, 1);

    pthread_create(&r1, NULL, reader, NULL);
    pthread_create(&r2, NULL, reader, NULL);
    pthread_create(&w1, NULL, writer, NULL);

    pthread_join(r1, NULL);
    pthread_join(r2, NULL);
    pthread_join(w1, NULL);

    sem_destroy(&mutex);
    sem_destroy(&db);
    return 0;
}
